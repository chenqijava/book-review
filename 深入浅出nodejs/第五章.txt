
内存控制

V8 GC回收机制

新生代
  Scavenge算法  用空间换时间
  From 空间  复制到  To 空间  只复制存活的对象（新生代中存活的是少数）
  晋升到老生代
     a. 是否已经经历过一次Scavenge
     b. To的空间占用超过25%
     两者满足一个即可晋升老生代

老生代
  Mark-Sweep & Mark-Compact
  Mark-Sweep会有两个阶段 标记 和 清除， 标记活的对象，清除死对象
  这会造成内存碎片，Mark-Compact是Mark-Sweep改进 对象标记为死亡后 将活着的对象往一端移动，然后直接清理边界外的内存

V8在这里选择Mark-Sweep & Mark-Compact结合， 通常使用Mark-Sweep
  当内存不够保存从新生代晋升的对象时，使用Mark-Compact

js作用域
  作用域链上的对象访问只能向上，无法访问内部变量

闭包： 实现外部作用域访问内部作用域中的变量


V8有内存限制  64位 1.4G 32位 0.7G
堆外内存： 不是由V8分配的内存  如Buffer对象（详见第六章）


内存泄漏：
  缓存（需要有过期策略）
  队列消费不及时 （队列阻塞）
  作用域未释放








